正则是个很有深度的话题，虽然学习有段时间了，自感所学甚浅，所以只是本文只是做个读书笔记。

1，元字符(正则表达式的运算字符)

	. 匹配除了换行符一以外的任意字符
	
	? 匹配0次或者1次
	
	* 匹配0次或者多次（贪婪模式，尽可能多的匹配）
	
	+ 匹配1次或者多次（贪婪模式，尽可能多的匹配）
	
	| 或 (比如 a|b ,匹配a或者b )

	( 代表子模式的开始
	
	) 代表子模式的结束
    
 	[ 代表集合的开始

	] 代表结合的结束

	{} 代表匹配次数，{2,3}表示匹配最少2次，最多3次

	\ 转义字符（对正则的元字符进行转义，使它失去特殊意义）


>ps: 下面2点需要特别说明
>
>  a,为了实现尽可能少的匹配，要用到懒惰模式（*？ 或者 +?）。
>
>
>  b,[ ]集合中的元字符，代表的是字符（包含上面提到的元字符），代表的是字符本身的含义，没有特殊含义

2, 位置字符
	
	\b 用来匹配一个单词（字母数字或者下划线）的开始或者结尾

	^ 代表字符串的开头

	$ 代表字符串的结尾

>ps: 请注意\b 和^,$的区别

3,其它字符

	\d 匹配数字
	\D 非数字
	\w 字母数字和下划线
	\W 非\w的字符
	\s 空格
	\S 非空格

4，回溯引用与子表达式

子表达式格式：（）

回溯引用：只是用来引用模式里的子表达式,回溯引用从 \1 开始

	举个栗子
	
	待匹配字符串：
	str = 'adb adb'
	
	目标字符：
	adb adb
	
	正则表达式：
	(adb)\s\1
	
5，前后查询（也叫零宽断言）
	？= 正向前查询
     
    ？<= 正向后查询

	？！ 负正向前查询(与 ?= 要匹配的字符成非的关系)

	?<! 负正向后查询(？<= 正向后查询的匹配字符成非的关系)

**需要特别说明的是：(?:expr)	忽略捕获的子模式**


6.python中的re模块，对元字符的影响

	标志	              含义
	DOTALL, S	      使 . 匹配包括换行在内的所有字符
	IGNORECASE, I	  使匹配对大小写不敏感
	LOCALE, L	      做本地化识别（locale-aware）匹配
	MULTILINE, M	  多行匹配，影响 ^ 和 $
	VERBOSE, X	      能够使用 REs 的 verbose 状态，使之被组织得更清晰易懂


**当M标志指定后， "^" 匹配字符串的开始和字符串中每行的开始。同样的， $ 元字符匹配字符串结尾和字符串中每行的结尾（直接在每个换行之前）。**


写在最后：《正则表达式必知必会》作者有个观点：正则表达式没有绝对的正确与否，只是看适不适合，只有通过亲身实践才能正则掌握它